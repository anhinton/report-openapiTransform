<?xml version="1.0" encoding="UTF-8"  ?>
<!DOCTYPE document [
<!ENTITY mdash "&#x2014;">
<!ENTITY ndash "&#x2013;">
<!ENTITY us "_">
<!ENTITY tilde "~">
<!ENTITY bar "|">
<!ENTITY pcnt "&#37;">
]>
<document xmlns:xi="http://www.w3.org/2001/XInclude">
  
  <metadata>
    <title>Transforming documents with OpenAPI pipelines</title>
    <author>
      <name>Ashley Noel Hinton</name>
      <email>ahin017@aucklanduni.ac.nz</email>
    </author>
    <author>
      <name>Paul Murrell</name>
      <email>paul@stat.auckland.ac.nz</email>
    </author>
    <affiliation>Department of Statistics, The University of Auckland</affiliation>
    <date></date>
    <description>Technical report on transforming documents using an
    OpenAPI pipeline.</description>
  </metadata>

  <body>
    <section id="introduction">
      <p></p>
    </section>

    <!-- end section -->

    <section>    
      <h1>A markup transformable document format</h1>
            
    </section>

    <!-- end section -->

    <section>
      <h1>The <code>document</code> markup format</h1>

      <p>The transformable document format described in this report is
      an XML file with <code>document</code> as the root element. This
      document has two child elements: <code>metadata</code> and
      <code>body</code>.</p>

      <p>The <code>metadata</code> element contains the document metadata,
      with elements for the document <code>title</code> and
      <code>subtitle</code>, <code>author</code> information,
      <code>date</code> of publication, and a <code>description</code>
      section. An example <code>metadata</code> element follows:</p>

      <pre><code><xi:include href="metadataExample.xml" parse="text">
	<xi:fallback>xinclude metadataExample.html</xi:fallback>
      </xi:include></code></pre>

      <p>The <code>body</code> element contains the document's main
      content. The following elements are used in the same way as they
      are used in HTML
      (<url>https://www.w3.org/TR/html-markup/elements.html</url>):</p>

      <ul>
	<li><code>a</code> &ndash; hyperlink</li>
	<li><code>code</code> &ndash; code fragment</li>
	<li><code>em</code> &ndash; emphatic stress</li>
	<li><code>figcaption</code> &ndash; figure caption</li>
	<li><code>figure</code> &ndash; figure with optional caption</li>
	<li><code>h1</code> &ndash; heading</li>
	<li><code>h2</code> &ndash; heading</li>
	<li><code>h3</code> &ndash; heading</li>
	<li><code>img</code> &ndash; image</li>
	<li><code>li</code> &ndash; list item</li>
	<li><code>ol</code> &ndash; ordered list</li>
	<li><code>p</code> &ndash; paragraph</li>
	<li><code>pre</code> &ndash; preformatted text</li>
	<li><code>q</code> &ndash; quoted text</li>
	<li><code>section</code> &ndash; section</li>
	<li><code>strong</code> &ndash; strong importance</li>
	<li><code>ul</code> &ndash; unordered list</li>
      </ul>

      <p>The <code>&lt;url&gt;</code> element is introduced in the
      <code>document</code> format to indicate a hyperlink where the
      enclosed URL is both the href and the value. The following code
      block demonstrates the use of the <code>url</code> element:</p>

      <pre><code><xi:include href="elementsExample.xml" parse="text">
	<xi:fallback><todo>xinclude elementsExample.xml</todo></xi:fallback>
      </xi:include></code></pre>

      <p>The resulting output:</p>

      <xi:include href="elementsExample.xml" parse="xml">
	<xi:fallback><todo>xinclude elementsExample.xml</todo></xi:fallback>
      </xi:include>

      <p>The <code>document</code> XML format uses
      <code>&lt;code&gt;</code> elements to indicate blocks of
      computer code, just as in HTML. Dynamic code chunks which are to
      be executed are marked using the <code>class</code> attribute to
      <code>code</code>. For example chunks of R code which are to be
      executed used the Knitr package are wrapped in a
      <code>&lt;code&gt;</code> element with
      <code>class="knitr"</code>. An author can also provide a
      <code>name</code> attribute for the knitr code chunk, as well as
      knitr <code>options</code>. A document author can also use
      <code>CDATA</code> sections to wrap code with reserved XML
      characters. The following code demonstrates how to include an R
      code chunk to be executed with Knitr:</p>

      <pre><code><xi:include href="knitrExample.xml" parse="text">
	<xi:fallback><todo>xinclude knitrExample.xml</todo></xi:fallback>
      </xi:include></code></pre>

      <p>And the following is the result of executing this code
      chunk:</p>

      <xi:include href="knitrExample.xml" parse="xml">
	<xi:fallback><todo>xinclude knitrExample.xml</todo></xi:fallback>
      </xi:include>

      <p>The <code>document</code> format also makes use of the
      <code>include</code> element from XInclude
      (<url>http://www.w3.org/2001/XInclude</url>) namespace to
      include XML content from external files. This allows
      <code>document</code> authors to embed other documents which may
      be authored separately from the main document. There is no
      simple method of doing this directly in either HTML or Pandoc
      Markdown.</p>

      <p>The next sections describes some simple transformations which
      can be performed on the <code>document</code> markup format
      using freely available open source tools. This report was itself
      written in the <code>document</code> markup format&mdash;the
      source code is available at <url>report.xml</url>.</p>
    </section>

    <!-- end section -->

    <section>
      <h1>Using OpenAPI pipelines for transformation</h1>

      <p>The OpenAPI architecture helps to break tasks in data
      analysis down into small pieces making it easier for people to
      contribute to a data problem. The goal of the OpenAPI project is
      to make it easier for people to connect with data. Meaningful
      steps in a data workflow can be wrapped as modules. Modules can
      be arranged in pipelines, and shared to be recombined by other
      authors in their own pipelines. Pipelines and modules can be
      executed by OpenAPI glue system software. The whole project is
      open source, and open to contributions from anyone
      (<a href="http://stattech.wordpress.fos.auckland.ac.nz/2015-01-introducing-openapi/">Introducing
      OpenAPI</a>,
      <a href="http://stattech.wordpress.fos.auckland.ac.nz/2016-08-openapi-version-0-6/">OpenAPI
      version 0.6</a>).</p>

      <p>It is OpenAPI's dividing of tasks into modules which makes it
      an ideal candidate for handling document
      transformation. Transforming the <code>document</code> format
      described in the previouse section can be broken down into
      several discrete steps:</p>

      <ol>
	<li>Merge XML code indicated by <code>xi:include</code>
	elements into the document.</li>
	<li>Convert XML character entities into appropriate
	characters.</li>
	<li>Convert document into output format language.</li>
	<li>Execute embedded chunks of code.</li>
      </ol>

      <p>Several technologies already exist for handling each of these
      steps. For example, the xmllint
      (<url>http://www.xmlsoft.org/</url>) command line tool can
      replace XInclude code, and replace entities with their
      values. The xsltproc (ibid.) command line tool can be used to
      apply an XSL stylesheet to the <code>document</code> to produce
      the desired output format. The Knitr package in R can be used to
      execute chunks of R code in various document formats.</p>

      <p>What the OpenAPI architecture offers is the ability to wrap
      transformation steps in a module which takes a file as an input,
      and produces another file as an output. The output of one module
      can be passed as the intput of another module, thus building a
      pipeline which describes the entire transformation. Each module
      in an OpenAPI pipeline specifies its execution language, meaning
      an OpenAPI pipeline can have access to a wide variety of
      tools.</p>

      <p>In the following section I will descibe the modules used to
      transform a tranformable <code>document</code> file to HTML
      output, including the processing of chunks of R code. After this
      section I will show how this pipeline can be modified to produce
      PDF and Markdown output from the same source
      <code>document</code>.</p>
	
      <h2>Transformation to HTML</h2>

      <p>The first pipeline example, <code>toHtml</code>, converts a
      <code>document</code> source file to an HTML file with embedded
      R code, and the results of executing this R code.</p>

      <code class = "knitr" name = "toHtmlGraph"
	    options = "echo = FALSE, message = FALSE, results = 'hide'">
	<![CDATA[library(gridGraphviz)
nodes <- structure(c("xinclude", "substituteEntities",
                     "convertToRhtml", "knitToHtml",
                     "report.xml", "report.html"),
                   .Names = c("xinclude", "substituteEntities",
                              "convertToRhtml", "knitToHtml",
                              "report.xml", "report.html"))
edgeList <- structure(list(
    xinclude = "substituteEntities", substituteEntities = "convertToRhtml", 
    convertToRhtml = "knitToHtml", knitToHtml = "report.html",
    `report.xml` = "xinclude",
    `report.html` = character(0)),
    .Names = c("xinclude", "substituteEntities", "convertToRhtml",
               "knitToHtml",
               "report.xml", "report.html"))
toHtmlGraph <- new("graphNEL", nodes = nodes, edgeL = edgeList,
                   edgemode = "directed")
Ragraph <- agopenTrue(
    graph = toHtmlGraph, name = "",
    attrs= list(node = list(shape = "ellipse")),
    nodeAttrs = list(shape = c("report.xml" = "polygon",
                               "report.html" = "polygon")))
png("toHtmlGraph.png", width = graphWidth(Ragraph) * 96,
    height = graphHeight(Ragraph) * 96)
grid.graph(Ragraph, newpage = TRUE)
dev.off()
]]></code>

      <figure>
	<img src = "toHtmlGraph.png"/>
	<figcaption>The toHtml pipeline</figcaption>
      </figure>

      <h3>Include referenced XML</h3>

      <p>The first module in the <code>toHtml</code> pipeline is the
      <code>xinclude</code> module, which processes all of the
      <code>&lt;xi:include&gt;</code> elements in the source document
      and produces a document with the reference XML documents
      inline. The <code>xinclude</code> module is a
      <q>bash</q>-language module, and wraps a bash script which calls
      the <code>xmllint</code> command-line tool to perform the
      transformation. This module requires four input objects:
      <q>report</q> which references the source document,
      <url>report.xml</url>; <q>metadataExample</q> which references
      the XML file <url>metadataExample.xml</url>;
      <q>elementsExample</q> which references the XML file
      <url>elementsExample.xml</url>; and <q>knitrExample</q> which
      references the XML file <url>knitrExample.xml</url>. The module
      produces a single output, <q>report</q>, which references the
      transformed XML file produced by the transformation. The XML
      source for the <code>xinclude</code> module can be found at
      <url>transform/toHtml/xinclude.xml</url>.</p>

      <h3>XML entities</h3>

      <p>The second transformation module in the pipeline is the
      <code>substituteEntities</code> module. This module replaces the
      XML entities in the source document with the values provided in
      the document's doctype declaration. The
      <code>substituteEntities</code> module is a <q>bash</q>-language
      module with one input, <q>report</q>, an XML file provided by
      the <code>xinclude</code> module. This module wraps a script
      which uses the <code>xmllint</code> command-line tool to replace
      the source documents XML entities with their values. The module
      produces one output, <q>report</q>, which references the
      transformed source XML file. The XML source for the
      <code>substituteEntities</code> module can be found at
      <url>transform/toHtml/substituteEntities.xml</url>.</p>

      <h3>Produce <code>.Rhtml</code> file</h3>

      <p>The third module in this pipeline is the
      <code>convertToRhtml</code> module. This module transforms the
      source document into an HTML document with Knitr R code
      chunks. This module is a <q>bash</q>-language module with two
      inputs: <q>report</q>, an XML file provided by the
      <code>substituteEntities</code> module; and <q>toRhtml</q>,
      which references an XSLT stylesheet file
      <url>xsl/toRhtml.xsl</url>, which describes the
      transformation. The module wraps a script which uses the
      <code>xsltproc</code> command-line tool to transform the source
      document into a Knitr HTML file. The module produces one output,
      <q>report</q>, which references the Knitr HTML file produced in
      the transformation. The XML source for the
      <code>convertToRhtml</code> module can be found at
      <url>transform/toHtml/convertToRhtml.xml</url>.</p>

      <h3>Produce <code>.html</code> file</h3>

      <p>The fourth module in the <code>toHtml</code> pipeline is the
      <code>knitToHtml</code> module. This module executes the R code
      chunks in a Knitr HTML file and returns the resulting HTML
      file. This module is a <q>R</q>-language module with one input,
      <q>report</q>, a Knitr HTML file provided by the
      <code>convertToRhtml</code> module. The module wraps an R script
      which call the <code>knit</code> function from the Knitr package
      to execute the R code chunks and returns an HTML file. The
      module produces two outputs: <q>report</q>, which references the
      HTML file produced by the module source script, and
      <q>toHtmlGraph</q>, a PNG image file. <todo>update with
      toPdfGraph AND propagate module to toPdf pipeline</todo>. The
      XML source for the <code>knitToHtml</code> module can be found
      at <url>transform/toHtml/knitToHtml.xml</url>.</p>

      <!-- end section -->
      
      <h2>Transformation to PDF</h2>

      <p>The second pipeline example, <code>toPdf</code>, converts a
      <code>document</code> source file to a LaTeX file</p>

      <code class = "knitr" name = "toPdfGraph"
	    options = "echo = FALSE, message = FALSE, results = 'hide'">
      <![CDATA[nodes <- structure(
    c("xinclude", "substituteEntities", "convertToRhtml", 
      "knitToHtml", "latexChars", "latexEntities",
      "commentCode", "convertToRtex", "knitToLatex", "latexToPdf",
      "report.xml", "report.html", "report.pdf"),
    .Names = c("xinclude", "substituteEntities",
               "convertToRhtml", "knitToHtml", "latexChars",
               "latexEntities", "commentCode", "convertToRtex",
               "knitToLatex", "latexToPdf",
               "report.xml", "report.html", "report.pdf"))
edgeList <- structure(
    list(xinclude = c("substituteEntities", "latexChars"),
         substituteEntities = "convertToRhtml",
         convertToRhtml = "knitToHtml",
         knitToHtml = "report.html",
         latexChars = "latexEntities", latexEntities = "commentCode",
         commentCode = "convertToRtex", convertToRtex = "knitToLatex",
         knitToLatex = c("latexToPdf", "latexToPdf"),
         latexToPdf = "report.pdf",
         `report.xml` = "xinclude",
         `report.html` = character(0),
         `report.pdf` = character(0)),
    .Names = c("xinclude", "substituteEntities", "convertToRhtml",
               "knitToHtml", "latexChars", "latexEntities", "commentCode",
               "convertToRtex", "knitToLatex", "latexToPdf",
               "report.xml", "report.html", "report.pdf"))
toPdfGraph <- new("graphNEL", nodes = nodes, edgeL = edgeList,
                   edgemode = "directed")
Ragraph <- agopenTrue(
    graph = toPdfGraph, name = "",
    attrs = list(node = list(shape = "ellipse")),
    nodeAttrs = list(shape = c("latexChars" = "hexagon",
                               "latexEntities" = "hexagon",
                               "commentCode" = "hexagon",
                               "convertToRtex" = "hexagon",
                               "knitToLatex" = "hexagon",
                               "latexToPdf" = "hexagon",
                               "report.xml" = "polygon",
                               "report.html" = "polygon",
                               "report.pdf" = "polygon"
                               )))
png("toPdfGraph.png", width = graphWidth(Ragraph) * 96,
     height = graphHeight(Ragraph) * 96)
grid.graph(Ragraph, newpage = TRUE)
dev.off()
]]></code>

      <figure>
	<img src = "toPdfGraph.png"/>
	<figcaption>The toPdf pipeline</figcaption>
      </figure>

      <h3>Substitute LaTeX entity values</h3>

      <p>The first new module in the <code>toPdf</code> pipeline is
      the <code>texChars</code> module. This module replaces the
      entity definitions in the source document doctype declaration
      with values appropriate to LaTeX character typesetting&mdash;the
      source document entity values are appropriate to HTML. This
      module is a <q>bash</q>-language module with one input,
      <q>report</q>, an XML file provided by the <code>xinclude</code>
      module. The module wraps a bash script which substitutes the
      entity values using the <code>sed</code> command-line tool. The
      module produces one output, <q>report</q>, which references the
      transformed XML file. The XML source for the
      <code>latexChars.xml</code> module can be found at
      <url>transform/toPdf/latexChars.xml</url>.</p>

      <h3>XML entities</h3>

      <p>The <code>latexEntities</code> modules is identical to the
      <code>substituteEntities</code> module in the
      <code>toHtml</code> pipeline. It takes its input from the
      <code>texChars</code> modules, and produces the output
      <q>report</q>, which references the transformed source
      document. The source XML for <code>latexEntities</code> is the
      same as for <code>substituteEntities</code>,
      <url>transform/toHtml/substituteEntities.xml</url>.</p>

      <h3>R code comments</h3>

      <p>The <code>commentCode</code> module adds the LaTeX comment
      character, <q>&pcnt;</q>, to the beginning of each line of R
      code identified by <code>&lt;code class = "knitr"&lt;</code>, to
      conform to the Knitr packages standards for R code chunks in a
      Knitr LaTeX document. This module is an <q>R</q>-language module
      with its one input, <q>report</q>, provided by the
      <code>latexEntities</code> module. The module wraps a source
      script which uses the XML package to perform the required
      transformation on the <code>code</code> elements with class set
      to <q>knitr</q>. The module produces one output, <q>report</q>,
      which references the transformed source document. The XML source
      for the <code>commentCode</code> module can be found at
      <url>transform/toPdf/commentCode.xml</url>.</p>

      <h3>Produce <code>.Rtex</code> file</h3>

      <p>The <code>convertToRtex</code> module transforms the source
      XML document into a LaTeX document with Knitr R code
      chunks. This module is a <q>bash</q>-language module with two
      inputs: <q>report</q>, which is provided by the
      <code>commentCode</code> module; and <q>toRtex</q>, which
      references the XSLT stylesheet <url>xsl/toRtex.xsl</url>. The
      module wraps a bash script which transforms the source document
      to a LaTeX document using the command-line tool
      <code>xsltproc</code>. The module produces one output,
      <q>report</q>, which references the Knitr LaTeX file resulting
      from the transformation. The XML source for the
      <code>convertToRtex</code> module can be found at
      <url>transform/toPdf/convertToRtex.xml</url>.</p>

      <h3>Produce <code>.tex</code> file</h3>

      <p>The <code>knitToLatex</code> module executes the chunks of R
      code in a Knitr LaTeX file and produces a LaTeX file. This is an
      <q>R</q>-language module with a single input, <q>report</q>,
      provided by the <code>convertToRtex</code> module. The module
      wraps an R script which call the <code>knit</code> function from
      the Knitr package to execute the R code chunks and returns a
      LaTeX file. The module produces two outputs: <q>report</q>,
      which references the LaTeX file produced; and
      <q>toHtmlGraph</q>, a PNG image file. <todo>update with
      toPdfGraph</todo>. The XML source for the
      <code>knitToLatex</code> module can be found at
      <url>transform/toPdf/knitToLatex.xml</url>.</p>

      <h3>Produce <code>.pdf</code> file</h3>

      <p>The <code>latexToPdf</code> module produces a PDF file from a
      LaTeX source file. This is a <q>bash</q>-language module with
      two inputs: <q>report</q> and <q>toHtmlGraph</q>, which are
      provided by the <code>knitToLatex</code> module. <todo>update
      with toPdfGraph</todo>. The module wraps a bash script which
      produces a PDF file using the <code>pdflatex</code> command-line
      tool. The module produces one output, <q>report</q>, the PDF
      file produced from the LaTeX source file. The XML source for the
      <code>latexToPdf</code> module can be found at
      <url>transform/toPdf/latexToPdf.xml</url>.</p>

    </section>

    <!-- end section -->

    <section>
      <h1>Background</h1>
    </section>

    <!-- end section -->

    <section>
      <h1>Technical requirements</h1>

      <p>This is an appendix section.</p>
    </section>
  </body>
  
</document>
